银行家算法是一种避免死锁的算法。在避免死锁方法中允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配资源的安全性，若分配不会导致系统进入不安全状态，则分配，否则等待。、
为了实现银行家算法，必须设置以下四个数据结构:
（1）可利用资源向量Available:其初始值是系统中所配置的该类全部可用资源的数目。
（2）最大需求矩阵Max:它定义了系统中n个进程中的每一个进程对m类资源的最大需求。
（3）分配矩阵Allocation:它定义了系统中每一类资源当前已分配给每一个进程的资源数。
（4）需求矩阵Need：用一表示每一个进程尚需的各类资源数。
a.
 资源
进程	Max	Allocation	Need
	A	B	C	A	B	C	A	B	C
P1	5	5	9	2	1	2	3	4	7
P2	5	3	6	4	0	2	1	3	4
P3	4	0	11	4	0	5	0	0	6
P4	4	2	5	2	0	4	2	2	1
P5	4	2	4	3	1	4	1	1	0
A,B,C的Available为2，3，3
T0时刻处于安全状态，安全序列为：P4，P2，P3，P5，P1。
b.
Request2(0,3,4)<=Need2(1,3,4)
Request2(0,3,4)>Available(2,3,3)
让P2等待
所以，不能分配。
c.
Request4(2,0,1)<=Need4(2,2,1)
Request4(2,0,1)<=Available(2,3,3)
系统暂时假定给P4分配资源：
资源
进程	Max	Allocation	Need
	A	B	C	A	B	C	A	B	C
P1	5	5	9	2	1	2	3	4	7
P2	5	3	6	4	0	2	1	3	4
P3	4	0	11	4	0	5	0	0	6
P4	4	2	5	4	0	5	0	2	0
P5	4	2	4	3	1	4	1	1	0
A,B,C的Available为0，3，2
 
给出一个安全序列：P4, P5, P1, P2, P3。
此时处于安全状态，所以能够实施资源分配
d.
Request1(0,2,0)<=Need1(3,4,7) 
Request1(0,2,0)<=Available(0,3,2) 
系统暂时假定给P1分配资源： 
资源
进程	Max	Allocation	Need
	A	B	C	A	B	C	A	B	C
P1	5	5	9	2	3	2	3	2	7
P2	5	3	6	4	0	2	1	3	4
P3	4	0	11	4	0	5	0	0	6
P4	4	2	5	4	0	5	0	2	0
P5	4	2	4	3	1	4	1	1	0
A,B,C的Available为0，1，2
此时不存在安全序列，所以不能实施资源分配
